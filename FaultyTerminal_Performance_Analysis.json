{
  "file": "/Users/tmmac3/Coding/websites/Nexo-Main/Nexo 2.0/nexo-vision/src/components/ui/FaultyTerminal.tsx",
  "issues": [
    {
      "line": 182,
      "problem": "Conditional branch in fragment shader: 'if (uGlitchAmount != 1.0)' causes branch divergence in GPU, reducing parallelism. This check happens per-pixel every frame.",
      "severity": "HIGH",
      "category": "Shader Efficiency",
      "fix": "Use conditional operator to avoid branching: 'p.x += extra * step(abs(uGlitchAmount - 1.0), 0.001);' or pre-compute if glitch is enabled"
    },
    {
      "line": 209,
      "problem": "Conditional barrel distortion branch: 'if(uCurvature != 0.0)' adds branch divergence per-fragment. Every pixel evaluates this every frame.",
      "severity": "HIGH",
      "category": "Shader Efficiency",
      "fix": "Use mix() instead: 'uv = mix(uv, barrel(uv), step(0.001, abs(uCurvature)));'"
    },
    {
      "line": 216,
      "problem": "Chromatic aberration calls getColor() 3 times conditionally. With branch divergence, this is expensive. Fragment shader calls digit() 9 times per pixel, multiplied 3 times = 27 digit() calls per pixel when CA enabled.",
      "severity": "CRITICAL",
      "category": "Shader Efficiency",
      "fix": "Pre-compute CA offset outside conditional. Cache color samples. Consider sampling reduced resolution for aberration channels."
    },
    {
      "line": 187,
      "problem": "digit() function called 9 times per pixel (once centered, 8 neighbors for anti-aliasing). With chromatic aberration enabled, this becomes 27 calls. High computational cost for every pixel.",
      "severity": "HIGH",
      "category": "Shader Efficiency",
      "fix": "Reduce neighborhood sampling to 5-tap filter or use 4 corner samples instead of 9. Implement mip-mapping or pre-filtered lookup."
    },
    {
      "line": 84,
      "problem": "fbm() function creates 3 rotating matrices and 3 noise samples per call. Pattern() calls fbm() 3 times per digit evaluation. This is called 9+ times per pixel.",
      "severity": "CRITICAL",
      "category": "Shader Efficiency",
      "fix": "Limit FBM octaves or use analytical noise approximation. Pre-compute pattern texture offline if possible. Cache noise results."
    },
    {
      "line": 124,
      "problem": "Mouse interaction always computed in digit() even when uUseMouse is 0. Distance calculation and exponential per-pixel.",
      "severity": "MEDIUM",
      "category": "Shader Efficiency",
      "fix": "Move mouse logic outside digit() function or use: 'intensity += mix(0.0, mouseInfluence, step(0.5, uUseMouse));'"
    },
    {
      "line": 134,
      "problem": "Page load animation has per-cell delay calculation using expensive trigonometric dot products (sin, dot, vec2 constants) even when progress = 1.0 (animation complete).",
      "severity": "MEDIUM",
      "category": "Shader Efficiency",
      "fix": "Skip animation calculations when uPageLoadProgress >= 0.99. Send separate uniform flag 'uAnimationComplete' from JS side."
    },
    {
      "line": 405,
      "problem": "Frame throttling at 30fps uses hardcoded 33ms delta. No adaptive throttling based on device capability or visibility. Wastes time on invisible elements.",
      "severity": "MEDIUM",
      "category": "Visibility Pausing",
      "fix": "Already has visibility check at line 402. Consider reducing to 24fps or 20fps for background rendering. Make throttle rate configurable."
    },
    {
      "line": 344,
      "problem": "iResolution uniform updates on every resize, creating new Color object. No change detection - unnecessary re-allocation.",
      "severity": "LOW",
      "category": "Memory Leaks",
      "fix": "Check if resolution actually changed before creating new Color: 'if (oldWidth !== newWidth || oldHeight !== newHeight) { ... }'"
    },
    {
      "line": 313,
      "problem": "Color object created during initialization using canvas dimensions passed to Color() constructor, but Color() expects RGB normalized values (0-1), not pixel dimensions. Values likely clamped to 1.0.",
      "severity": "MEDIUM",
      "category": "WebGL Optimization",
      "fix": "Pass normalized resolution: 'new Color(1.0, 1.0, gl.canvas.width / gl.canvas.height)' or use correct uniform format"
    },
    {
      "line": 225,
      "problem": "Dither computation with hash21() uses expensive trigonometric operations per-pixel. Called every frame when uDither > 0.",
      "severity": "LOW",
      "category": "Shader Efficiency",
      "fix": "Use built-in texture sampling or shift-based hash if dither is optional. Reduce dither precision or skip on lower-end devices."
    },
    {
      "line": 338,
      "problem": "Mesh created once but geometry (Triangle) potentially recreated on DPR changes. No geometry caching between re-initializations.",
      "severity": "LOW",
      "category": "Memory Leaks",
      "fix": "Move geometry creation outside DPR-dependent effect or cache Triangle instance"
    },
    {
      "line": 356,
      "problem": "Mouse event listener added only if mouseReact is true, but mouseRef is always updated. No performance gain from conditional listener. Listener never removed during component life on prop change.",
      "severity": "LOW",
      "category": "Memory Leaks",
      "fix": "Add/remove listener when mouseReact prop changes using separate useEffect. Include in cleanup."
    },
    {
      "line": 428,
      "problem": "Mouse smoothing damping happens every frame regardless of whether mouse has moved. Small impact but unnecessary work when mouse position is stable.",
      "severity": "VERY_LOW",
      "category": "Optimization",
      "fix": "Cache previous smooth position and skip calculations if delta is below threshold (0.0001)"
    },
    {
      "line": 277,
      "problem": "timeOffsetRef uses Math.random() * 100 to vary animation across instances. No memoization - new random value each mount, but acceptable since used once.",
      "severity": "VERY_LOW",
      "category": "Optimization",
      "fix": "Already optimized by using useRef. No change needed."
    },
    {
      "line": 363,
      "problem": "WebGL context loss extension call happens in cleanup. Missing null check on gl before calling getExtension. gl could be undefined if cleanup fires after unmount.",
      "severity": "LOW",
      "category": "Memory Leaks",
      "fix": "Add guard: 'gl?.getExtension(...)?. ...' with optional chaining"
    }
  ],
  "summary": {
    "totalIssues": 15,
    "criticalIssues": 2,
    "highSeverity": 3,
    "mediumSeverity": 4,
    "lowSeverity": 5,
    "verylowSeverity": 1,
    "keyFindings": [
      "CRITICAL: Fragment shader has excessive computational complexity. Chromatic aberration combined with 9-tap digit sampling creates 27 digit() function calls per pixel, each calling fbm() 3 times with expensive noise operations.",
      "CRITICAL: Branch divergence in shader from conditional statements (glitch, curvature, CA, mouse) causes GPU thread divergence, reducing parallel efficiency.",
      "HIGH: FBM and noise functions are expensive (3 rotations + 3 sine operations per octave, 3 octaves). Called 27+ times per pixel with CA enabled.",
      "HIGH: 9-tap neighborhood sampling for anti-aliasing is excessive. Consider 5-tap or analytical anti-aliasing.",
      "MEDIUM: Unnecessary computation in shader when effects disabled (mouse at line 124, animation at lines 134-141).",
      "MEDIUM: Frame throttling works but is hardcoded to 30fps with no adaptive scaling.",
      "GOOD: Component properly implements visibility-based pausing with useVisibilityPause hook (line 281, 402).",
      "GOOD: Proper WebGL cleanup and resource management in useEffect returns.",
      "GOOD: DPR capped at 1.5 for performance (line 261).",
      "GOOD: Separate effects for setup, uniforms, and animation loop improves organization."
    ],
    "recommendedActions": [
      "Replace fragment shader conditionals with analytical operators (step, mix, smoothstep)",
      "Reduce chromatic aberration to 2-channel instead of separate R and B samples",
      "Implement texture-based noise instead of in-shader computation",
      "Reduce anti-aliasing samples from 9 to 5 (cross pattern) or implement adaptive sampling",
      "Add shader compilation flags to completely remove unused effect code paths",
      "Consider downsampling render target for high-DPI devices",
      "Implement GPU-based motion vectors and temporal anti-aliasing",
      "Profile on mobile devices - current shader is desktop-heavy"
    ],
    "performanceImpact": {
      "shaderOverhead": "HIGH - Fragment shader does 27-100+ operations per pixel depending on feature combinations. On 1920x1080, that's 5.5+ billion operations per frame at 60fps.",
      "memoryLeak_risk": "LOW - Proper cleanup implemented, minor issues in edge cases",
      "visibilityPause_effectiveness": "HIGH - Properly implemented and respects component visibility",
      "estimatedFrameTime_1080p_desktop": "16.7ms at 60fps - likely 8-12ms shader time depending on GPU"
    }
  }
}

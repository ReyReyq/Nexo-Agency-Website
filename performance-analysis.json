{
  "file": "/Users/tmmac3/Coding/websites/Nexo-Main/Nexo 2.0/nexo-vision/src/components/ui/VariableProximity.tsx",
  "issues": [
    {
      "line": 206,
      "problem": "Arbitrary 100ms timeout for initial position calculation. This delay is inefficient and could cause layout shift. Should use useLayoutEffect or requestAnimationFrame for synchronous positioning.",
      "severity": "medium",
      "category": "performance",
      "fix": "Replace setTimeout(updateLetterPositions, 100) with useLayoutEffect or requestAnimationFrame to avoid arbitrary delays and potential jank."
    },
    {
      "line": 229,
      "problem": "animationCallback dependency array includes 'containerRef' which is a mutable ref object. This causes the callback to be recreated every render despite the ref not changing, leading to unnecessary hook re-runs.",
      "severity": "high",
      "category": "unnecessary_re-renders",
      "fix": "Remove 'containerRef' from dependency array since refs don't trigger dependency changes. The ref is accessed, not used as a dependency."
    },
    {
      "line": 242,
      "problem": "Inside animationCallback, all letter style updates happen in a tight loop. While batched, accessing letterRef.style.fontVariationSettings triggers DOM updates synchronously. This happens at 60fps, multiplied by letter count.",
      "severity": "high",
      "category": "animation_overhead",
      "fix": "Consider debouncing style updates or using CSS custom properties with requestAnimationFrame to batch updates. Alternative: Use transform/opacity for smoother animations instead of fontVariationSettings."
    },
    {
      "line": 256,
      "problem": "Inside the animation loop (line 242 forEach), string interpolation happens every frame: `'${axis}' ${interpolatedValue}` and .join(', '). This creates new string objects for every letter every frame.",
      "severity": "medium",
      "category": "resource-heavy_operations",
      "fix": "Pre-compute string format or use template literals more efficiently. Cache computed values when they haven't changed."
    },
    {
      "line": 265,
      "problem": "Setting letterRef.style.fontVariationSettings directly on DOM every frame. With 100+ letters, this triggers 100+ DOM writes per frame (60fps = 6000+ writes/sec). No caching of previous value to skip unnecessary updates.",
      "severity": "critical",
      "category": "resource-heavy_operations",
      "fix": "Add caching: only set fontVariationSettings if the value actually changed from the previous frame. Compare with interpolatedSettingsRef before writing."
    },
    {
      "line": 288,
      "problem": "Using array index as key (key={wordIndex}) in word map. This causes React reconciliation issues if words change, leading to unnecessary re-renders and refs getting mismatched.",
      "severity": "high",
      "category": "unnecessary_re-renders",
      "fix": "Use unique, stable identifiers. Since words are static text, use `key={`${word}-${wordIndex}`}` or restructure to avoid index-based keys."
    },
    {
      "line": 289,
      "problem": "currentLetterIndex is derived from a mutable variable (letterIndex++) that increments during render. This can cause inconsistent indexing if component re-renders. The letterIndex counter is not stable across renders.",
      "severity": "high",
      "category": "unnecessary_re-renders",
      "fix": "Use useMemo to compute letter indices once and cache them. Avoid mutation during render: const letterIndices = useMemo(() => { let idx = 0; return words.flatMap(w => w.split('').map(() => idx++)); }, [words]);"
    },
    {
      "line": 293,
      "problem": "Ref callback (ref={el => { letterRefs.current[currentLetterIndex] = el; }}) is created inline without memoization. This callback recreates every render, causing all motion.span children to unmount/remount their refs.",
      "severity": "high",
      "category": "unnecessary_re-renders",
      "fix": "Memoize the ref callback using useCallback: const setLetterRef = useCallback((index, el) => { letterRefs.current[index] = el; }, []);"
    },
    {
      "line": 251,
      "problem": "Setting fontVariationSettings to fromFontVariationSettings every frame when distance >= radius. If letter was already at this setting, this is unnecessary DOM write. No equality check before setting.",
      "severity": "medium",
      "category": "resource-heavy_operations",
      "fix": "Cache previous style value: if (interpolatedSettingsRef.current[index] !== fromFontVariationSettings) { letterRef.style.fontVariationSettings = fromFontVariationSettings; }"
    },
    {
      "line": 218,
      "problem": "Using updateLetterPositions function reference directly in addEventListener for 'resize' event. Function is recreated when containerRef changes, requiring event listener removal and re-attachment.",
      "severity": "medium",
      "category": "event_listener_leaks",
      "fix": "Create a stable event handler wrapper: const handleResize = useCallback(() => updateLetterPositions(), [updateLetterPositions]); Use this in addEventListener instead."
    },
    {
      "line": 172,
      "problem": "calculateFalloff function uses Math.exp for gaussian falloff. This is called once per letter per frame (potentially 100+ letters Ã— 60fps). Math.exp is expensive compared to polynomial approximation.",
      "severity": "low",
      "category": "resource-heavy_operations",
      "fix": "Consider using a lookup table or polynomial approximation for gaussian falloff: norm * Math.exp(-2 * distance/radius) is cheaper than full gaussian."
    },
    {
      "line": 114,
      "problem": "IntersectionObserver created with threshold: 0.1 and rootMargin: '100px'. This observer runs frequently. When component unmounts, observer.disconnect() is called but no check for containerRef existence during disconnect.",
      "severity": "low",
      "category": "event_listener_leaks",
      "fix": "Add null check: if (observer && containerRef?.current) { observer.disconnect(); }"
    },
    {
      "line": 256,
      "problem": "parsedSettings is in the dependency array for animationCallback (line 266), but it's derived from memoized values. It's recreated on every frame due to dependency chain issues, causing animationCallback to recreate.",
      "severity": "medium",
      "category": "unnecessary_re-renders",
      "fix": "Ensure parsedSettings is properly memoized and only changes when actual settings change. Currently it's derived inside animationCallback's dependencies."
    }
  ],
  "summary": {
    "critical_issues": 1,
    "high_severity": 5,
    "medium_severity": 5,
    "low_severity": 2,
    "total_issues": 13,
    "performance_categories": {
      "unnecessary_re-renders": 4,
      "animation_overhead": 1,
      "resource-heavy_operations": 4,
      "event_listener_leaks": 2,
      "general_performance": 2
    },
    "key_findings": "The component has a critical DOM write performance issue (line 265) where fontVariationSettings is written to DOM every frame without checking if the value changed. With 100+ letters at 60fps, this results in 6000+ unnecessary DOM operations per second. Additional issues include unstable ref callbacks, mutable index counters during render, and expensive string concatenation in animation loops. The component also has several unnecessary re-render triggers from incorrect dependency arrays and index-based keys.",
    "estimated_impact": "High CPU usage (animation thread), potential jank, battery drain on mobile devices, and degraded user experience with large text blocks.",
    "recommended_priority": [
      "1. Fix critical DOM write caching (line 265) - immediate impact",
      "2. Memoize ref callback (line 293) - prevents child remounting",
      "3. Use stable letter indices (line 289) - fixes reconciliation",
      "4. Fix index keys (line 288) - prevents re-render issues",
      "5. Remove containerRef from dependencies (line 229) - reduces callback recreation"
    ]
  }
}
